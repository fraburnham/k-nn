<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1424389225085">{:repl-history {:ide [], :local [&quot;(map #(println subspaces %) dataset)&quot; &quot;(group-point subspaces (second dataset))&quot; &quot;(group-point subspaces (nth dataset 20))&quot; &quot;(group-point subspaces (nth dataset 10))&quot; &quot;(loop [d dataset\n       r []]\n  (if (empty? d)\n    r\n    (recur (rest d)\n           (conj r (group-point subspaces (first d))))))&quot; &quot;(count dataset)&quot; &quot;(group-point subspaces (nth dataset 100))&quot; &quot;(group-point subspaces (nth dataset 127))&quot; &quot;(defn group-point [subspaces point]\n  (map (fn [division-lines p]\n         (loop [d division-lines\n                i 0]\n           (if (or (&lt; p (first d)) (empty? d))\n             i\n             (recur (rest d) (inc i)))))\n       subspaces (:features point)))\n\n(loop [d dataset\n       r []]\n  (println d r)\n  (if (empty? d)\n    r\n    (recur (rest d)\n           (conj r (group-point subspaces (first d))))))&quot; &quot;(defn group-point [subspaces point]\n  (map (fn [division-lines p]\n         (loop [d division-lines\n                i 0]\n           (if (or (&lt; p (first d)) (empty? d))\n             i\n             (recur (rest d) (inc i)))))\n       subspaces (:features point)))\n\n(loop [d dataset\n       r []]\n  (println d)\n  (if (empty? d)\n    r\n    (recur (rest d)\n           (conj r (group-point subspaces (first d))))))&quot; &quot;(defn group-point [subspaces point]\n  (map (fn [division-lines p]\n         (loop [d division-lines\n                i 0]\n           (if (or (&lt; p (first d)) (empty? d))\n             i\n             (recur (rest d) (inc i)))))\n       subspaces (:features point)))\n\n(loop [d dataset\n       r []]\n  (println (type d))\n  (if (empty? d)\n    r\n    (recur (rest d)\n           (conj r (group-point subspaces (first d))))))&quot; &quot;(loop [d dataset\n       r []]\n  (println (count d) (empty? d))\n  (if (empty? d)\n    r\n    (recur (rest d)\n           (conj r (group-point subspaces (first d))))))&quot; &quot;(loop [d dataset\n       r []]\n  (println (count d) (empty? d))\n  (if (empty? d)\n    (do (println \&quot;Here\&quot;) r)\n    (recur (rest d)\n           (conj r (group-point subspaces (first d))))))&quot; &quot;(defn group-point [subspaces point]\n  (map (fn [division-lines p]\n         (loop [d division-lines\n                i 0]\n           (if (or (&lt; p (first d)) (empty? d))\n             (do (println i) i)\n             (recur (rest d) (inc i)))))\n       subspaces (:features point)))&quot; &quot;(defn group-point [subspaces point]\n  (map (fn [division-lines p]\n         (loop [d division-lines\n                i 0]\n           (if (or (&lt; p (first d)) (empty? d))\n             (do (println i) i)\n             (recur (rest d) (inc i)))))\n       subspaces (:features point)))\n&quot; &quot;(loop [d dataset\n       r []]\n  (println (count d) (empty? d))\n  (if (empty? d)\n    (do (println \&quot;Here\&quot; r) r)\n    (recur (rest d)\n           (conj r (group-point subspaces (first d))))))&quot; &quot;(nth dataset 8)&quot; &quot;(group-point subspaces (nth dataset 8))&quot; &quot;(map (partial group-point subspaces) dataset)&quot; &quot;(def point (first dataset)\n  )&quot; &quot;point&quot; &quot;(assoc point :subspace '(1 3 1 1))&quot; &quot;(iterate (fn [r x] (println r x)) 0)&quot; &quot;(iterate (fn [x] (println r x)) 0)&quot; &quot;(iterate (fn [x] (println x)) 0)&quot; &quot;(take 4)&quot; &quot;(take 4 (iterate (fn [x] (println x)) 0))&quot; &quot;(take 4 (iterate (fn [x] (println x) 0) 0))&quot; &quot;extremes&quot; &quot;(define-subspaces extremes 4)&quot; &quot;(find-extremes dataset)&quot; &quot;(def input '(6.8 3.0 5.0 2.0))&quot; &quot;input-subspace&quot; &quot;(defn update-subspaces [dataset subspaces]\n  (map #(assoc % :subspace (group-point subspaces %)) dataset))&quot; &quot;(update-subspaces dataset subspaces)&quot; &quot;(def dataset )&quot; &quot;(def dataset (update-subspaces dataset subspaces))&quot; &quot;(def input-subspace (group-point subspaces {:features input}))&quot; &quot;(map (fn [point] (if (= (:subspace point) input-subspace) point)) dataset)&quot; &quot;(defn same-subspace? [input-subspace point]\n  (if (= input-subspace (:subspace point)) true false))&quot; &quot;(filter (partial same-subspace? input-subspace) dataset)&quot; &quot;(def subspace-dataset (filter (partial same-subspace? input-subspace) dataset))&quot; &quot;(map :features subspace-dataset)&quot; &quot;(defn subspace-distances [dataset input]\n  (flatten\n    (pmap #(map (fn [point]\n                  {:distance (euclidean-distance input (:features point))\n                   :class (:class point)\n                   :features (:features point)})\n                %)\n          (partition-all partition-const dataset)))\n  )&quot; &quot;(def distances (subspace-distances subspace-dataset input))&quot; &quot;(def distances- (subspace-distances subspace-dataset input))&quot; &quot;distances-&quot; &quot;(nn 1 distances-)&quot; &quot;(def tests (format-csv-data \&quot;iris-test-data.csv\&quot;))&quot; &quot;(last tests)&quot; &quot;(count tests)&quot; &quot;(nth tests 20)&quot; &quot;(naive-abs 4)&quot; &quot;(naive-abs -4)&quot; &quot;(def test-data (flatten (map (fn [p n] [p (- 0 n)]) (partition 2 (range)))))&quot; &quot;(def test-data (flatten (map (fn [[p n]] [p (- 0 n)]) (partition 2 (range)))))&quot; &quot;(take 10 test-data)&quot; &quot;(take 10000 test-data)&quot; &quot;(def a (time (map #(Math/abs %) (take 10000 test-data))))&quot; &quot;(time (map #(Math/abs %) (take 10000 test-data)))&quot; &quot;(time (map naive-abs (take 10000 test-data)))&quot; &quot;(time (doall (map #(Math/abs %) (take 10000 test-data))))&quot; &quot;(time (doall (map naive-abs (take 10000 test-data))))&quot; &quot;(defn naive-abs [x]\n  (memoize\n    ((fn [x]\n       (if (neg? x) (- 0 x) x)))))&quot; &quot;(defn naive-abs [x]\n  (memoize #(if (neg? x) (- 0 x) x)))&quot; &quot;(naive-abs -10)&quot; &quot;(defn nb (naive-abs -19))&quot; &quot;(def nb (naive-abs -19))&quot; &quot;nb&quot; &quot;(nb)&quot; &quot;(defn naive-abs [x]\n  (if (neg? x) (- 0 x) x))&quot; &quot;(def abs (memoize naive-abs))&quot; &quot;(abs -10)&quot; &quot;(time (doall (map abs (take 10000 test-data))))&quot; &quot;dataset&quot; &quot;(trial)&quot; &quot;(def d (format-csv-data \&quot;iris-data.csv\&quot;))\n(def tests (format-csv-data \&quot;iris-test-data.csv\&quot;))\n(def extremes (find-extremes d))\n(def subspaces (define-subspaces extremes 4))\n(def dataset (update-subspaces d subspaces))&quot; &quot;(first tests)&quot; &quot;(def input (:features (first tests)))&quot; &quot;(distances dataset subpsaces input)&quot; &quot;(subspace-distances dataset '())&quot; &quot;(subspace-distances '() '(5.8 2.7 5.1 1.9))&quot; &quot;(conj '(1 2 3) 3)&quot; &quot;(cons '(1 2 3) 3)&quot; &quot;(cons '(1 2 3) '(3))&quot; &quot;(concat '(1 2 3) '(3))&quot; &quot;(concat '(1 2 3) 3)&quot; &quot;subspaces&quot; &quot;(map rest subspaces)&quot; &quot;(map #(concat (rest %) (last %)) subspaces)&quot; &quot;(map #(concat (rest %) (list (last %))) subspaces)&quot; &quot;(distances dataset subspaces input)&quot; &quot;(group-point subspaces input)&quot; &quot;input&quot; &quot;(group-point subspaces {:features input})&quot; &quot;(map (fn fizz-buzz [n] \n       (cond (mod n 3) (print \&quot;fizz\&quot;)\n             (mod n 5) (print \&quot;buzz\&quot;)\n             :else (print n))\n       (println)) (range 101))&quot; &quot;(map (fn fizz-buzz [n]\n       (if (zero? (mod n 3)) (print \&quot;fizz\&quot;))\n       (if (zero? (mod n 5)) (print \&quot;buzz\&quot;))\n       (if (or (not (zero? (mod n 3))) (or (not (zero? (mod n 5))))\n               (print n)))\n       (println)) (range 101))&quot; &quot;(map (fn fizz-buzz [n]\n       (if (zero? (mod n 3)) (print \&quot;fizz\&quot;))\n       (if (zero? (mod n 5)) (print \&quot;buzz\&quot;))\n       (if (or (not (zero? (mod n 3))) (not (zero? (mod n 5))))\n               (print n))\n       (println)) (range 101))&quot; &quot;(map (fn fizz-buzz [n]\n       (if (zero? (mod n 3)) (print \&quot;fizz\&quot;))\n       (if (zero? (mod n 5)) (print \&quot;buzz\&quot;))\n       (if (and (not (zero? (mod n 3))) (not (zero? (mod n 5))))\n               (print n))\n       (println)) (range 101))&quot; &quot;(map (fn fizz-buzz [n]\n       (if (zero? (mod n 3)) \&quot;fizz\&quot;)\n       (if (zero? (mod n 5)) \&quot;buzz\&quot;)\n       (if (and (not (zero? (mod n 3))) (not (zero? (mod n 5))))\n               n)) \n     (range 101))&quot; &quot;(map (fn fizz-buzz [n]\n       (if (zero? (mod n 3)) (str \&quot;fizz\&quot;))\n       (if (zero? (mod n 5)) (str \&quot;buzz\&quot;))\n       (if (and (not (zero? (mod n 3))) (not (zero? (mod n 5))))\n               n)) \n     (range 101))&quot;], :remote []}}</component>
</project>

