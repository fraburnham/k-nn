<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1424271614217">{:repl-history {:ide [], :local [&quot;(def t (map #(clojure.string/split % #\&quot;,\&quot;) (clojure.string/split (slurp \&quot;iris-data.csv\&quot;) #\&quot;\\n\&quot;)))&quot; &quot;(map #{} '(1 2 3))&quot; &quot;(map #{1} '(1 2 3))&quot; &quot;(map #{%} '(1 2 3))&quot; &quot;(map #({%}) '(1 2 3))&quot; &quot;(map #{(keyword %) %} '(1 2 3))&quot; &quot;(map #({(keyword %) %}) '(1 2 3))&quot; &quot;(assoc {} :key 'val)&quot; &quot;(map #(assoc {} :features (drop-last %) :class (last %)) t)&quot; &quot;(map #(assoc {} \n             :features (Float/parseFloat (drop-last %)) \n             :class (Float/parseFloat (last %))) t)&quot; &quot;(map #(assoc {} \n             :features (Float/parseFloat (drop-last %)) \n             :class (map #(Float/parseFloat %) (last %))) t)&quot; &quot;(map #(assoc {} \n             :features (Float/parseFloat (drop-last %)) \n             :class (map #(Float/parseFloat %) (last %)) t))&quot; &quot;(map #(assoc {} \n             :features (Float/parseFloat (drop-last %)) \n             :class (last %)) t)&quot; &quot;(map #(assoc {} \n             :features (drop-last %) \n             :class (Integer/parseInt (last %))) t)&quot; &quot;(map #(assoc {} \n             :features (map #(Float/parseFloat %) (drop-last %)) \n             :class (Integer/parseInt (last %))) t)&quot; &quot;(map #(assoc {} \n             :features (map (fn [x] (Float/parseFloat x)) (drop-last %)) \n             :class (Integer/parseInt (last %))) t)&quot; &quot;(k-nn.core-test/trial)&quot; &quot;(require '[clojure.string :as s])&quot; &quot;(defn format-csv-data [filename]\n  (map #(assoc {}\n               :features (map (fn [x] (Float/parseFloat x)) (drop-last %))\n               :class (Integer/parseInt (last %)))\n       (map #(s/split % #\&quot;,\&quot;)\n            (s/split (slurp filename) #\&quot;\\n\&quot;))))\n\n(defn trial []\n  (let [dataset (format-csv-data \&quot;iris-data.csv\&quot;)\n        tests (format-csv-data \&quot;iris-test-data.csv\&quot;)]\n    (println dataset)\n    (map (fn [test]\n           (println (classify 5 dataset (:features test)))\n           (println \&quot;Expected:\&quot; (:class test)))\n         tests)))\n&quot; &quot;(format-csv-data \&quot;iris-data.csv\&quot;)&quot; &quot;(defn trial []\n  (let [dataset (format-csv-data \&quot;iris-data.csv\&quot;)\n        tests (format-csv-data \&quot;iris-test-data.csv\&quot;)]\n    (map (fn [test]\n           (println (classify 5 dataset (:features test)))\n           (println \&quot;Expected:\&quot; (:class test)))\n         tests)))&quot; &quot;(trial)&quot; &quot;(println \&quot;Hello world!\&quot;)&quot; &quot;(def x [(repeat 10 [0 0])])&quot; &quot;(def x (repeat 10 [0 0]))&quot; &quot;(def x (repeat 10 '(0 0)))&quot; &quot;x&quot; &quot;(min '(1 2 3 4 5 -3))&quot; &quot;(apply min '(1 2 3 4 -9))&quot; &quot;(apply (comp min max) '(1 2 3 4 -9))&quot; &quot;(apply #([(min %) (max %)]) '(1 2 3 4 -9))&quot; &quot;(apply #([(min %)]) '(1 2 3 4 -9))&quot; &quot;(apply #(min %) '(1 2 3 4 -9))&quot; &quot;(apply #(min) '(1 2 3 4 -9))&quot; &quot;(apply (fn [&amp; vals]\n         [(min vals)\n          (max vals)]) '(1 2 3 4 -9))&quot; &quot;(apply (fn [&amp; vals]\n         [(apply min vals)\n          (apply max vals)]) '(1 2 3 4 -9))&quot; &quot;((fn [&amp; vals]\n     [(apply min vals)\n      (apply max vals)]) '(1 2 3 4 -9))&quot; &quot;((fn [&amp; vals]\n   (println vals)\n     [(apply min vals)\n      (apply max vals)]) '(1 2 3 4 -9))&quot; &quot;((fn [vals]\n   (println vals)\n     [(apply min vals)\n      (apply max vals)]) '(1 2 3 4 -9))&quot; &quot;(defn format-csv-data [filename]\n  (map #(assoc {}\n         :features (map (fn [x] (Float/parseFloat x)) (drop-last %))\n         :class (Integer/parseInt (last %)))\n       (map #(s/split % #\&quot;,\&quot;)\n            (s/split (slurp filename) #\&quot;\\n\&quot;))))&quot; &quot;(def dataset (format-csv-data \&quot;iris-data.csv\&quot;))&quot; &quot;(def dimension (count (:features (first dataset))))&quot; &quot;dimension&quot; &quot;(:features (first dataset))&quot; &quot;(map #(nth (:features %) 0) dataset)&quot; &quot;(apply min (map #(nth (:features %) 0) dataset))&quot; &quot;((fn [vals] \n   [(apply min vals)\n    (apply max vals)]) \n  (map #(nth (:features %) 0) dataset))&quot; &quot;((fn [vals] \n   [(apply min vals)\n    (apply max vals)]) \n  (map #(nth (:features %) 1) dataset))&quot; &quot;((fn [vals] \n   [(apply min vals)\n    (apply max vals)]) \n  (map #(nth (:features %) 2) dataset))&quot; &quot;((fn [vals] \n   [(apply min vals)\n    (apply max vals)]) \n  (map #(nth (:features %) 3) dataset))&quot; &quot;(find-extremes [dataset])&quot; &quot;(def extremes [])&quot; &quot;(conj extremes\n      ((fn [vals]\n         (println vals)\n         [(apply min vals)\n          (apply max vals)])\n        (map #(nth (:features %) i) dataset)))&quot; &quot;(conj extremes\n      ((fn [vals]\n         (println vals)\n         [(apply min vals)\n          (apply max vals)])\n        (map #(nth (:features %) 0) dataset)))&quot; &quot;(conj extremes\n      ((fn [vals]\n         (println vals)\n         [(apply min vals)\n          (apply max vals)])\n        (map #(nth (:features %) 1) dataset)))&quot; &quot;(def extremes (conj extremes\n      ((fn [vals]\n         (println vals)\n         [(apply min vals)\n          (apply max vals)])\n        (map #(nth (:features %) 0) dataset))))&quot; &quot;(def extremes (conj extremes\n      ((fn [vals]\n         (println vals)\n         [(apply min vals)\n          (apply max vals)])\n        (map #(nth (:features %) 1) dataset))))&quot; &quot;(def extremes (conj extremes\n      ((fn [vals]\n         (println vals)\n         [(apply min vals)\n          (apply max vals)])\n        (map #(nth (:features %) 2) dataset))))&quot; &quot;(def extremes (conj extremes\n      ((fn [vals]\n         (println vals)\n         [(apply min vals)\n          (apply max vals)])\n        (map #(nth (:features %) 3) dataset))))&quot; &quot;(let [dimension (count (:features (first dataset)))]\n  (loop [i 0\n         extremes []]\n    (println extremes)\n    (println i)\n    (if (= i dimension)\n      extremes\n      (recur (inc i)\n             (conj extremes\n                   ((fn [vals]\n                      [(apply min vals)\n                       (apply max vals)])\n                     (map #(nth (:features %) i) dataset)))))))&quot; &quot;(defn find-extremes [dataset]\n  (let [dimension (count (:features (first dataset)))]\n    (loop [i 0\n           extremes []]\n      (println extremes)\n      (println i)\n      (if (= i dimension)\n        extremes\n        (recur (inc i)\n               (conj extremes\n                     ((fn [vals]\n                        [(apply min vals)\n                         (apply max vals)])\n                       (map #(nth (:features %) i) dataset))))))))&quot; &quot;(find-extremes dataset)&quot; &quot;(time (find-extremes dataset))&quot; &quot;(map (partial apply -) extremes)&quot; &quot;(map (comp Math/abs (partial apply -)) extremes)&quot; &quot;(map (comp #(Math/abs %) (partial apply -)) extremes)&quot; &quot;(def distances (map (comp #(Math/abs %) (partial apply -)) extremes))&quot; &quot;(def extreme-diffs (map (comp #(Math/abs %) (partial apply -)) extremes))&quot; &quot;(def division-sizes (map #(/ % divisions) extreme-diffs))&quot; &quot;(def division-sizes (map #(/ % 4) extreme-diffs))&quot; &quot;division-sizes&quot; &quot;(def divisions 4)&quot; &quot;(def division-lines (map (fn [extreme division-size]\n                           (loop [r [extreme]\n                                  i 0]\n                             (if (= i divisions)\n                               r\n                               (recur (conj r (+ (last r) division-size))\n                                      (inc i)))))\n                         (map first extremes) division-sizes))&quot; &quot;extremes&quot; &quot;(map first division-lines)&quot; &quot;(take 5 (range))&quot; &quot;(def subspaces division-lines)&quot; &quot;(def point (first dataset))&quot; &quot;point&quot; &quot;(map (fn [division-lines p]\n       (map (fn [d i]\n              ;check if p &lt; d if so this is the right\n              ;bound to this point, dump out the index\n              (if (&lt; p d) i))\n            division-lines (range)))\n     subspaces (:features point))&quot; &quot;(map (fn [division-lines p]\n       (loop [d division-lines\n              i 0]\n         (if (&lt; p d)\n           i\n           (recur (rest d) (inc i))))\n       #_(map (fn [d i]\n              ;check if p &lt; d if so this is the right\n              ;bound to this point, dump out the index\n              (if (&lt; p d) i))\n            division-lines (range)))\n     subspaces (:features point))&quot; &quot;(map (fn [division-lines p]\n       (loop [d division-lines\n              i 0]\n         (if (&lt; p (first d))\n           i\n           (recur (rest d) (inc i))))\n       #_(map (fn [d i]\n              ;check if p &lt; d if so this is the right\n              ;bound to this point, dump out the index\n              (if (&lt; p d) i))\n            division-lines (range)))\n     subspaces (:features point))&quot; &quot;(defn group-point [subspaces point]\n  ;find the subspace coordinates that a point belongs to\n  ;add that data to the point for easy searching later on\n  (map (fn [division-lines p]\n         ;did I lose my touch or something? another loop that I couldn't\n         ;figure out how to map right\n         (loop [d division-lines\n                i 0]\n           (if (&lt; p (first d))\n             i\n             (recur (rest d) (inc i)))))\n       subspaces (:features point)))&quot; &quot;(defn group-point [subspaces point]\n  ;find the subspace coordinates that a point belongs to\n  ;add that data to the point for easy searching later on\n  (map (fn [division-lines p]\n         ;did I lose my touch or something? another loop that I couldn't\n         ;figure out how to map right\n         (loop [d division-lines\n                i 0]\n           (if (or (&lt; p (first d)) (empty? d))\n             i\n             (recur (rest d) (inc i)))))\n       subspaces (:features point)))&quot; &quot;(defn group-point [subspaces point]\n  ;find the subspace coordinates that a point belongs to\n  ;add that data to the point for easy searching later on\n  (map (fn [division-lines p]\n         ;did I lose my touch or something? another loop that I couldn't\n         ;figure out how to map right\n         (loop [d division-lines\n                i 0]\n           (print i d)\n           (if (or (&lt; p (first d)) (empty? d))\n             i\n             (recur (rest d) (inc i)))))\n       subspaces (:features point)))&quot; &quot;\n(map (partial group-point subspaces) dataset)&quot; &quot;dataset&quot; &quot;(map :features dataset)&quot; &quot;(map (fn [division-lines p]\n       ;did I lose my touch or something? another loop that I couldn't\n       ;figure out how to map right\n       (loop [d division-lines\n              i 0]\n         (print i d)\n         (if (or (&lt; p (first d)) (empty? d))\n           i\n           (recur (rest d) (inc i)))))\n     subspaces (:features point))&quot; &quot;(map (fn [division-lines p]\n       ;did I lose my touch or something? another loop that I couldn't\n       ;figure out how to map right\n       (loop [d division-lines\n              i 0]\n         (if (or (&lt; p (first d)) (empty? d))\n           i\n           (recur (rest d) (inc i)))))\n     subspaces (:features point))&quot; &quot;(defn group-point [subspaces point]\n  (map (fn [division-lines p]\n         (loop [d division-lines\n                i 0]\n           (if (or (&lt; p (first d)) (empty? d))\n             i\n             (recur (rest d) (inc i)))))\n       subspaces (:features point)))&quot; &quot;(group-point subspaces (first dataset))&quot; &quot;(map (partial group-point subspaces) dataset)&quot; &quot;(map #(group-point subspaces %) dataset)&quot; &quot;(map (fn [point] (println point)) dataset)&quot; &quot;subspaces&quot; &quot;division-lines&quot; &quot;(defn group-point [subspaces point]\n  (println subspaces point)\n  (map (fn [division-lines p]\n         (loop [d division-lines\n                i 0]\n           (if (or (&lt; p (first d)) (empty? d))\n             i\n             (recur (rest d) (inc i)))))\n       subspaces (:features point)))&quot; &quot;()&quot; &quot;(map (fn [point] (group-point subspaces point)) dataset)&quot; &quot;(map (fn [point] (println subspaces point)) dataset)&quot;], :remote []}}</component>
</project>

